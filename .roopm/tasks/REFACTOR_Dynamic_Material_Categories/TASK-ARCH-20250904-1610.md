+++
# MDTM Task Metadata
id = "TASK-ARCH-20250904-1610"
title = "Phase 1: Architecture & Database Design for Dynamic Material Categories"
status = "🟢 Done"
type = "🏗️ Architecture"
priority = "high"
assigned_to = "core-architect"
coordinator = "roo-commander"
created_date = "2025-09-04T16:10:00Z"
updated_date = "2025-09-04T16:35:00Z"
estimated_effort = "1-2 weeks"
dependencies = []
tags = ["architecture", "database", "material-categories", "dynamic-config", "phase-1"]

# Context & Documentation
related_docs = [
    ".ruru/docs/architecture/dynamic-material-categories-refactoring-plan.md",
    ".roopm/tasks/FEATURE_Update_AI_Modules/TASK-OPENAI-20250903-1807.md",
    "src/types/materials.ts",
    "supabase/functions/pdf-extract/index.ts"
]

# Task Management
[acceptance_criteria]
database_schema = "Complete schema design for material_categories, material_properties, and category_validation_rules tables"
api_contracts = "REST and GraphQL API specifications with caching strategy"
performance_strategy = "Redis caching layer and database optimization plan"
migration_strategy = "Data preservation and backward compatibility approach"

[coordination]
parent_initiative = "Dynamic Material Categories Refactoring"
phase = 1
next_phase_dependency = "Phase 2: Configuration Service Implementation"
handoff_specialist = "dev-core-web, baas-supabase"
+++

# Task: Phase 1 Architecture & Database Design

## Description

Design the foundational architecture for migrating from hardcoded `MATERIAL_CATEGORIES` to a dynamic, database-backed configuration system. This phase addresses the architectural debt identified in [TASK-OPENAI-20250903-1807](./../FEATURE_Update_AI_Modules/TASK-OPENAI-20250903-1807.md) where `MATERIAL_CATEGORIES` is duplicated across 6+ files.

**Context:**
- Current `MATERIAL_CATEGORIES` hardcoded in [`src/types/materials.ts`](../../../src/types/materials.ts), [`supabase/functions/pdf-extract/index.ts`](../../../supabase/functions/pdf-extract/index.ts), and 4+ other files
- AI extraction modules tightly coupled to hardcoded categories
- Manual synchronization required when adding new material types
- Risk of inconsistency between frontend, backend, and AI modules

## Acceptance Criteria

### 1. Database Schema Design
- [ ] Complete table schema for `material_categories` with hierarchical support
- [ ] Complete table schema for `material_properties` with extensible metadata fields
- [ ] Complete table schema for `category_validation_rules` for AI extraction
- [ ] Migration scripts preserving existing data integrity
- [ ] Indexing strategy for optimal query performance

### 2. API Contract Specification
- [ ] REST endpoint specifications for category management
- [ ] GraphQL schema design for complex category queries
- [ ] WebSocket event definitions for real-time updates
- [ ] Caching headers and cache invalidation strategy
- [ ] Error handling and response format standards

### 3. Performance & Scalability Strategy
- [ ] Redis caching layer architecture design
- [ ] Edge function optimization strategy for global access
- [ ] Database query optimization and indexing plan
- [ ] CDN configuration for static metadata distribution
- [ ] Load balancing and failover mechanisms

### 4. Migration & Compatibility Strategy
- [ ] Backward compatibility approach for existing integrations
- [ ] Data migration plan from hardcoded sources to database
- [ ] Versioning strategy for category schema changes
- [ ] Rollback procedures and safety mechanisms
- [ ] Feature flag strategy for gradual rollout

## Detailed Checklist

### Database Architecture
- [✅] 📋 Analyze current `MATERIAL_CATEGORIES` structure in [`src/types/materials.ts`](../../../src/types/materials.ts)
- [✅] 📋 Review AI extraction requirements in [`supabase/functions/pdf-extract/index.ts`](../../../supabase/functions/pdf-extract/index.ts)
- [✅] 🗄️ Design `material_categories` table schema with hierarchical relationships
- [✅] 🗄️ Design `material_properties` table for dynamic metadata (finish, size, etc.)
- [✅] 🗄️ Design `category_validation_rules` table for AI extraction rules
- [✅] 🗄️ Create relationship mapping between tables
- [✅] 📝 Document database constraints and validation rules
- [✅] 📝 Define migration scripts for existing data preservation
- [✅] 🚀 Plan database indexing strategy for performance optimization

### API Design
- [✅] 📋 Define REST API endpoints for category CRUD operations
- [✅] 📋 Design GraphQL schema for complex category queries
- [✅] 📋 Specify WebSocket events for real-time category updates
- [✅] 📝 Document authentication and authorization requirements
- [✅] 📝 Define rate limiting and throttling policies
- [✅] 📝 Specify error response formats and status codes
- [✅] 🚀 Design API versioning strategy

### Performance Architecture
- [✅] 📋 Design Redis caching layer structure and keys
- [✅] 📋 Define cache invalidation triggers and strategies
- [✅] 📋 Plan edge function distribution for global access
- [✅] 📝 Specify cache TTL policies for different data types
- [✅] 📝 Design monitoring and alerting for cache performance
- [✅] 🚀 Plan database connection pooling and optimization

### Integration Planning
- [✅] 📋 Map current hardcoded usage patterns across platform
- [✅] 📋 Design backward compatibility layer for existing code
- [✅] 📋 Plan feature flag implementation for gradual migration
- [✅] 📝 Define integration testing requirements
- [✅] 📝 Specify rollback procedures and safety checks
- [✅] 📣 **Report Phase 1 completion to Coordinator**

## Technical Requirements

### Database Tables
1. **material_categories**
   - Primary key, name, description, parent_id (for hierarchy)
   - Properties: active, sort_order, created_at, updated_at
   - Constraints: unique names within parent scope

2. **material_properties**
   - Foreign key to material_categories
   - Property name, type, validation rules, default values
   - Support for dynamic property definitions

3. **category_validation_rules**
   - AI extraction rules and prompts per category
   - Validation patterns and confidence thresholds

### API Endpoints
- `GET /api/material-config/categories` - Fetch all categories
- `GET /api/material-config/categories/:id` - Fetch specific category
- `POST /api/material-config/categories` - Create new category (admin)
- `PUT /api/material-config/categories/:id` - Update category (admin)
- `DELETE /api/material-config/categories/:id` - Remove category (admin)

### Real-time Events
- `material_category_added`, `material_category_updated`, `material_category_removed`
- `material_config_synced`

## Notes

This is the critical foundation phase for the entire refactoring initiative. The quality of this architectural design will determine the success of all subsequent phases. Focus on creating a robust, scalable, and maintainable foundation that can support the platform's current and future material categorization needs.

**Key Decision Points:**
- Hierarchical vs flat category structure
- Performance vs consistency trade-offs
- Versioning and migration strategies
- Caching and distribution approaches

Deliverables from this phase will be handed off to [`dev-core-web`](../../../.ruru/modes/dev-core-web/) and [`baas-supabase`](../../../.ruru/modes/baas-supabase/) specialists for Phase 2 implementation.